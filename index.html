<div id="app">
  <h1>Using Promise.all()</h1>
  <ul>
    <li>
      What if we’re dealing with multiple promises, but we don’t care about the
      order?
    </li>
    <li>
      <em>Let’s think in terms of cleaning again.</em> For us to consider our
      house clean, we need our clothes to dry, our trash bins emptied, and the
      dishwasher to run.
    </li>
    <li>
      We need all of these tasks to complete but not in any particular order.
      Furthermore, since they’re all getting done asynchronously, they should
      really all be happening at the same time!
    </li>
    <li>
      To maximize efficiency we should use <code><em>concurrency</em></code
      >, multiple asynchronous operations happening together. With promises, we
      can do this with the function
      <code style="background-color: lightgray">Promise.all()</code>.
    </li>
    <li>
      <code style="background-color: lightgray">Promise.all()</code> accepts an
      array of promises as its argument and returns a single promise. That
      single promise will settle in one of two ways:
      <ol>
        <li>
          If every promise in the argument array resolves, the single promise
          returned from
          <code style="background-color: lightgray">Promise.all()</code> will
          resolve with an array containing the resolve value from each promise
          in the argument array.
        </li>
        <li>
          If any promise from the argument array rejects, the single promise
          returned from
          <code style="background-color: lightgray">Promise.all()</code> will
          immediately reject with the reason that promise rejected. This
          behavior is sometimes referred to as <em>failing fast</em>.
        </li>
      </ol>
    </li>
    <li>
      <h2>JavaScript Promises: Review</h2>
      <ol>
        <li>
          Promises are JavaScript objects that represent the eventual result of
          an asynchronous operation.
        </li>
        <li>
          Promises can be in one of three states: pending, resolved, or
          rejected.
        </li>
        <li>A promise is settled if it is either resolved or rejected.</li>
        <li>
          We construct a promise by using the <code><em>new</em></code> keyword
          and passing an executor function to the
          <code><em>Promise</em></code> constructor method.
        </li>
        <li>
          <code style="background-color: lightgray">setTimeout()</code> is a
          Node function which delays the execution of a callback function using
          the event-loop.
        </li>
        <li>
          We use <code style="background-color: lightgray">.then()</code> with a
          success handler callback containing the logic for what should happen
          if a promise resolves.
        </li>
        <li>
          We use <code style="background-color: lightgray">.catch()</code> with
          a failure handler callback containing the logic for what should happen
          if a promise rejects.
        </li>
        <li>
          Promise composition enables us to write complex, asynchronous code
          that’s still readable. We do this by chaining multiple
          <code style="background-color: lightgray">.then()</code>‘s and
          <code style="background-color: lightgray">.catch()</code>‘s.
        </li>
        <li>
          To use promise composition correctly, we have to remember to return
          promises constructed within a
          <code style="background-color: lightgray">.then()</code>.
        </li>
        <li>We should chain multiple promises rather than nesting them.</li>
        <li>
          To take advantage of concurrency, we can use
          <code style="background-color: lightgray">Promise.all()</code>.
        </li>
      </ol>
    </li>
  </ul>
</div>
